# low-rank-registration

Low-rank registration of slightly misaligned images for photometric stereo.

## Usage

The `lowrr` binary executable is provided automatically on each release of a tagged version.
(CF [list of tagged version][tags]).
When clicking on the download icon, select the "linux-musl" artifact.
It is generated by statically linking the musl lib in the binary such that `lowrr`
truely works on any recent or old linux distribution and doesn't have any runtime dependency.

[tags]: https://git.unicaen.fr/matthieu.pizenberg/low-rank-registration/-/tags

Below is the output of `lowrr --help`:

```txt
USAGE:
    lowrr [FLAGS] IMAGE_FILES
    For example:
        lowrr --trace *.png
        lowrr *.jpg 2> /dev/null
        lowrr *.png > result.txt

FLAGS:
    --help                 # Print this message and exit
    --version              # Print version and exit
    --out-dir dir/         # Output directory to save registered images (default: {})
    --trace                # Print more debug output to stderr while running
    --no-image-correction  # Avoid image correction
    --levels int           # Number of levels for the multi-resolution approach (default: {})
    --lambda float         # Weight of the L1 term (high means no correction) (default: {})
    --rho float            # Lagrangian penalty (default: {})
    --threshold float      # Stop when relative diff between two estimate of corrected image falls below this (default: {})
    --max-iterations int   # Maximum number of iterations (default: {})
    --image-max float      # Maximum possible value of the images for scaling (default: {})
```

## Lib documentation

The code of the project is split in two parts.
There is the `main.rs` which is a relatively small file.
This is the main entry point for the code generating the `lowrr` binary.
The rest is organized as a library, and can be easily re-used for other Rust applications.
The library code is fully documented, and the documentation is automatically
updated when new tagged versions are pushed.

The library documentation is available at:
http://matthieu.pizenberg.pages.unicaen.fr/low-rank-registration

## Unfamiliar with Rust?

If you want to read the source code but are not very familiar
with the Rust language, here are few syntax explanations.

Basically, if you know how to read C/C++ code, the structure of Rust
code should be pretty familiar, but with some unusual patterns.
For examples, the parts between brackets `<T>` are type parameters,
like templates in C++.

```rust
// Pattern 1: closures
let square = |x| x * x;
square(3) // -> 9

// Pattern 2: iterators
xCollection.iter().map(|x| f(x)).collect();

// Pattern 3: zipping iterators
xCollection.iter()
    .zip(yCollection.iter())
    .map(|(x,y)| f(x,y)).collect();

// Pattern 4: for loops on iterators
for x in xCollection.iter() {
    do_something_with(x)
}

// Pattern 5: crashing on potential errors
result.unwrap();
// or
result.expect("with an error message");
```

The first pattern is the usage of "closures",
a.k.a. "anonymous functions", a.k.a. "lambda functions".
The part between the bars `|x|` are the arguments.
The part after the bars `x * x` is the returned value.
Closures are useful to use instead of defining proper
"wordy" functions in some parts of the program.

The second pattern (`.iter().map(...)`) is basically saying that
we are iterating over a collection of things and we apply
the same function `f` to all those elements of the collection.
The `collect()` at the end is more or less saying that we are done
modifying it in this iterator, and we can regenerate a new
data structure that will contain the result of those modifications.

The third pattern consist in using `iterator1.zip(iterator2)`.
It is just to bring together two iterators and apply a function
to both elements at the same time.

Pattern 4 is another way of iterating, similar to pattern 1.
Depending on the situation, one or the other will be more appropiate.

Finally, the usage of `unwrap()` or `expect(...)` is just to say
to the compiler that I know it is safe to do something
even though it may result in an error.
In that case, just crash the program,
and print the message inside the `expect(...)`.

## Code contribution

To compile the source code yourself, you just need to install [Rust][rust],
and then run the command `cargo build --release`.
Cargo is Rust build tool, it will automatically download dependencies
and compile all the code.
The resulting binary will be located in `target/release/`.
The first compilation may take a little while, but then will be pretty fast.

[rust]: https://www.rust-lang.org/tools/install
